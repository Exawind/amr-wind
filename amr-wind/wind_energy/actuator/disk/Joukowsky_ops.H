#ifndef Joukowsky_OPS_H_
#define Joukowsky_OPS_H_

#include "amr-wind/wind_energy/actuator/disk/Joukowsky.H"
#include "amr-wind/wind_energy/actuator/disk/disk_ops.H"
#include "amr-wind/utilities/linear_interpolation.H"

namespace amr_wind {
namespace actuator {
namespace ops {

namespace joukowsky {
void parse_and_gather_params(const utils::ActParser& pp, JoukowskyData& data);
inline void
set_current_angular_velocity(JoukowskyData& data, const amrex::Real uInfSqr)
{
    const amrex::Real uInfMag = std::sqrt(uInfSqr);
    data.current_angular_velocity = ::amr_wind::interp::linear(
        data.table_velocity, data.angular_velocity, uInfMag);
}
void prepare_netcdf_file(
    const std::string& name,
    const JoukowskyData& data,
    const ActInfo& info,
    const ActGrid& grid);

void write_netcdf(
    const std::string& name,
    const JoukowskyData& data,
    const ActInfo& info,
    const ActGrid& /*unused*/,
    const amrex::Real time);
} // namespace joukowsky

template <>
struct ReadInputsOp<Joukowsky, ActSrcDisk>
{
    void operator()(Joukowsky::DataType& data, const utils::ActParser& pp)
    {
        auto& meta = data.meta();
        joukowsky::parse_and_gather_params(pp, meta);
        base::do_parse_based_computations<Joukowsky>(data);
    }
};

template <>
struct InitDataOp<Joukowsky, ActSrcDisk>
{
    void operator()(typename Joukowsky::DataType& data)
    {
        auto& grid = data.grid();
        auto& meta = data.meta();

        // only resize the members we are going to use
        grid.pos.resize(meta.num_force_pts);
        grid.force.resize(meta.num_force_pts);
        grid.vel.resize(meta.num_vel_pts);
        grid.vel_pos.resize(meta.num_vel_pts);
        meta.tip_correction.resize(meta.num_vel_pts_r);
        meta.root_correction.resize(meta.num_vel_pts_r);

        std::fill(meta.tip_correction.begin(), meta.tip_correction.end(), 1.0);

        if (meta.use_root_correction) {
            const amrex::Real dx = 1.0 / meta.num_vel_pts_r;

            const auto a = meta.root_correction_coefficient;
            const auto b = meta.root_correction_exponent;

            const auto delta = std::max(
                meta.vortex_core_size * meta.radius(),
                vs::DTraits<amrex::Real>::eps());

            const auto factor = dx / delta;

            for (int i = 0; i < meta.root_correction.size(); ++i) {
                meta.root_correction[i] =
                    1.0 - std::exp(-a * std::pow((i + 0.5) * factor, b));
            }
        } else {
            std::fill(
                meta.root_correction.begin(), meta.root_correction.end(), 1.0);
        }

        const auto& sVec = meta.sample_vec;
        const auto& nVec = meta.normal_vec;

        // force points
        base::compute_disk_points(meta, grid.pos, nVec, 0, 0);
        // velocity points upstream
        base::compute_disk_points(
            meta, grid.vel_pos, sVec, 0, meta.diameters_to_sample);
        // velocity points at the disk
        base::compute_disk_points(
            meta, grid.vel_pos, nVec, meta.num_vel_pts / 2, 0);
    }
};

/**
  @brief Compute Forces following procedures of Sorenson 2020

  Follow the procedure for computing body forces and applying tip/root
  corrections using a Joukowsky disk as outlined in:

  Sørensen, Jens Nørkær, et al. "Analytical body forces in numerical actuator
  disc model of wind turbines." Renewable Energy 147 (2020): 2259-2271.
 */
template <>
struct ComputeForceOp<Joukowsky, ActSrcDisk>
{
    void operator()(Joukowsky::DataType& data)
    {
        // Equation comments refer to Sorenson 2020 (full reference above)
        auto& grid = data.grid();
        auto& ddata = data.meta();
        const amrex::Real machine_eps = vs::DTraits<amrex::Real>::eps();
        ddata.disk_force *= 0.0;

        const amrex::Real uInfSqr = base::compute_reference_velocity_sqr(ddata);
        const amrex::Real U_ref = std::max(std::sqrt(uInfSqr), machine_eps);
        base::set_thrust_coefficient(ddata, uInfSqr);
        joukowsky::set_current_angular_velocity(ddata, uInfSqr);

        const amrex::Real Ct = ddata.current_ct;
        const amrex::Real dx = ddata.dr / ddata.radius();
        const amrex::Real dTheta =
            amr_wind::utils::two_pi() / ddata.num_vel_pts_t;

        const amrex::Real geometry_factor = ddata.dr * ddata.dr * dTheta * 0.5;

        const amrex::Real lambda =
            ddata.radius() * ddata.current_angular_velocity / U_ref;
        const amrex::Real lambda_2 = lambda * lambda;

        // step 0: compute tip correction based on current wind speed (eq 9)
        if (ddata.use_tip_correction) {
            auto& f = ddata.tip_correction;
            for (int i = 0; i < f.size(); ++i) {
                const auto x = (i + 0.5) * dx;
                f[i] = 2.0 / M_PI *
                       std::acos(std::exp(
                           -0.5 * ddata.num_blades * std::sqrt(1.0 + lambda_2) *
                           (1.0 - x)));
            }
        }

        // step 1: compute Ct, a1 and a2 coefficients (eq 16)
        amrex::Real a1 = 0.0;
        amrex::Real a2 = 0.0;

        for (int ip = 0; ip < ddata.num_vel_pts_r; ip++) {
            const amrex::Real x = std::max((ip + 0.5) * dx, machine_eps);

            a1 += std::pow(ddata.tip_correction[ip], 2.0) *
                  std::pow(ddata.root_correction[ip], 2.0) / x * dx;

            a2 += ddata.tip_correction[ip] * ddata.root_correction[ip] * x * dx;
        }

        // step 2: determine the circulation (q0) from a1, a2 and Ct (eq 17)

        const amrex::Real a2_2 = a2 * a2;

        const amrex::Real term1 = 16.0 * lambda_2 * a2_2;
        const amrex::Real term2 = 8.0 * Ct * a1;
        const amrex::Real term3 = 4.0 * lambda * a2;

        const amrex::Real numerator = std::sqrt(term1 + term2) - term3;

        const amrex::Real denominator = std::max(4.0 * a1, machine_eps);

        const amrex::Real q0 = numerator / denominator;

        // step 3: compute normal force (fz) and azimuthal force (f_theta) (eq
        // 13) and cp (eq 20)

        VecSlice disk_velocity = ::amr_wind::utils::slice(
            grid.vel, ddata.num_force_pts, ddata.num_force_pts);

        amrex::Real moment = 0.0;

        int ip = 0;

        for (int i = 0; i < ddata.num_vel_pts_r; i++) {
            const amrex::Real& F = ddata.tip_correction[i];
            const amrex::Real& g = ddata.root_correction[i];

            const amrex::Real x = std::max((i + 0.5) * dx, machine_eps);
            //            const amrex::Real& g = x;

            const amrex::Real f_z =
                q0 * g * F / x * (lambda * x + 0.5 * q0 * g * F / x);

            for (int j = 0; j < ddata.num_vel_pts_t; j++, ip++) {
                const auto point_current = grid.pos[ip];

                // TODO add sign convention for rotation (+/- RPM)
                const auto theta_vec = utils::compute_tangential_vector(
                    ddata.center, ddata.normal_vec, point_current);

                // normal vec by definition is opposite of the wind direction
                // so we need to flip the sign to give the actual disk velocity
                const amrex::Real u_disk_ij =
                    -ddata.normal_vec & disk_velocity[ip];

                const amrex::Real f_theta = u_disk_ij / U_ref * q0 * g * F / x;

                const amrex::Real dArea =
                    geometry_factor * (std::pow(i + 1.0, 2) - std::pow(i, 2));

                // eq 18
                moment += x * ddata.radius() * f_theta * dArea;

                grid.force[ip] =
                    (f_z * ddata.normal_vec + f_theta * theta_vec) *
                    ddata.density * uInfSqr * dArea;

                ddata.disk_force = ddata.disk_force + grid.force[ip];
            }
        }

        // equation 20
        const amrex::Real eq_20_denominator = std::max(
            0.5 * M_PI * ddata.density * std::pow(ddata.radius(), 2) *
                std::pow(U_ref, 3),
            machine_eps);

        ddata.current_cp = ddata.density * uInfSqr * moment *
                           ddata.current_angular_velocity / eq_20_denominator;
    }
};

template <>
struct ProcessOutputsOp<Joukowsky, ActSrcDisk>
{
private:
    // cppcheck-suppress uninitMemberVarPrivate
    Joukowsky::DataType& m_data;
    //! Path to the output directory (specified by Actuator physics class)
    std::string m_out_dir;

    //! NetCDF output filename for this turbine
    std::string m_nc_filename;

    //! Output frequency (specified in input file)
    int m_out_freq{10};

public:
    // cppcheck-suppress constParameter
    explicit ProcessOutputsOp<Joukowsky, ActSrcDisk>(Joukowsky::DataType& data)
        : m_data(data)
    {}
    void operator()(Joukowsky::DataType& /*data*/) {}
    void read_io_options(const utils::ActParser& pp)
    {
        pp.query("output_frequency", m_out_freq);
    }
    void prepare_outputs(const std::string& out_dir)
    {
        m_nc_filename = out_dir + "/" + m_data.info().label + ".nc";
        joukowsky::prepare_netcdf_file(
            m_nc_filename, m_data.meta(), m_data.info(), m_data.grid());
    }
    void write_outputs()
    {
        const auto& time = m_data.sim().time();
        const int tidx = time.time_index();
        if (tidx % m_out_freq != 0) {
            return;
        }

        joukowsky::write_netcdf(
            m_nc_filename, m_data.meta(), m_data.info(), m_data.grid(),
            time.new_time());
    }
};

} // namespace ops
} // namespace actuator
} // namespace amr_wind

#endif /* Joukowsky_OPS_H_ */
